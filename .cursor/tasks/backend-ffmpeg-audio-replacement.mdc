---
description: Implement FFmpeg pipeline to replace greeting segment audio in video
globs:
alwaysApply: false
---

id: "TASK-0002"
title: "Implement FFmpeg-based greeting audio replacement"
status: "planned"
priority: "P0"
labels: ["backend", "ffmpeg", "video", "audio"]
created: "2025-08-23"

# 1) High-Level Objective

Replace the initial greeting segment (e.g., "Hey Watermelon!") in an uploaded video’s audio track with AI-generated name audio, producing a seamless result.

# 2) Background / Context (Optional but recommended)

See `.cursor/rules/PRD.mdc` — MVP replaces the greeting with the synthesized name audio.

# 3) Assumptions & Constraints

- ASSUMPTION: Greeting occurs at the start of the video; configurable duration covers it.
- Constraint: Use FFmpeg available in runtime as `ffmpeg` CLI; if absent, document packaging plan.
- Constraint: Preserve original video track (no re-encode if possible) and overall loudness.

# 4) Dependencies (Other Tasks or Artifacts)

- tasks/backend-elevenlabs-tts-client.mdc

# 5) Context Plan

**Beginning (add to model context):**

- back/requirements.txt _(read-only)_
- back/src/apis/Db.py _(read-only)_

**End state (must exist after completion):**

- back/src/services/video_personalization.py
- back/src/services/**init**.py
- back/tests/unit/test_video_personalization.py

# 6) Low-Level Steps (Ordered, information-dense)

1. Create `back/src/services/video_personalization.py` with exported API:

   ```py
   import pathlib

   def replace_greeting_segment(
       input_video_path: str,
       replacement_audio_bytes: bytes,
       output_video_path: str,
       *,
       segment_start_sec: float = 0.0,
       segment_duration_sec: float = 1.5,
       audio_gain_db: float | None = None,
   ) -> None:
       """Replace audio in [segment_start_sec, start+duration] with `replacement_audio_bytes`. Writes `output_video_path`."""
   ```

   - Write `replacement_audio_bytes` to temp WAV/MP3 file.
   - Extract original audio to temp WAV using ffmpeg.
   - Build new audio:
     - `atrim` original to remove the first `segment_duration_sec` from start, keep suffix.
     - Concatenate replacement + remaining original using `concat` filter (ensure matching sample rate/channels; resample if needed).
     - Optionally apply `volume` filter if `audio_gain_db` provided.
   - Mux new audio with original video stream using `-c:v copy -map 0:v:0 -map [aout]`.
   - Ensure output container matches input extension.

2. Handle sample rate/channel normalization:

   - Force `-ar 48000 -ac 2` on both replacement and original audio paths before concat.

3. Add tests `back/tests/unit/test_video_personalization.py`:
   - Mock subprocess calls and assert constructed ffmpeg commands include expected filters/flags.
   - Guardrails: invalid paths raise; zero-length bytes raise.

# 7) Types & Interfaces (if applicable)

```py
def replace_greeting_segment(input_video_path: str, replacement_audio_bytes: bytes, output_video_path: str, *, segment_start_sec: float = 0.0, segment_duration_sec: float = 1.5, audio_gain_db: float | None = None) -> None: ...
```

# 8) Acceptance Criteria

- Function writes an output video where audio duration matches input video duration.
- Video stream copied without re-encoding; audio seamlessly replaced at beginning.
- Unit tests validate command construction and error handling paths.

# 9) Usage Examples (CLI/API)

```py
replace_greeting_segment("/tmp/in.mp4", tts_bytes, "/tmp/out.mp4", segment_duration_sec=1.2)
```

# 10) Notes / Links

- FFmpeg filters: `atrim`, `aresample`, `concat`, `amix`, `adelay`, `volume`.
